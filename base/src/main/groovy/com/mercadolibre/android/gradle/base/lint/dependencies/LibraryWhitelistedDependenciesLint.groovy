package com.mercadolibre.android.gradle.base.lint.dependencies

import com.mercadolibre.android.gradle.base.BasePlugin
import com.mercadolibre.android.gradle.base.lint.Lint
import groovy.json.JsonSlurper
import org.gradle.api.Project

/**
 * Class that lints the dependencies in the project checking that it only
 * compiles the whitelisted ones
 *
 * Author: Santi Aguilera
 */
class LibraryWhitelistedDependenciesLint implements Lint {

    private static final String ERROR_TITLE = "Error: The following dependencies are not allowed:"
    private static final String ERROR_ALLOWED_DEPENDENCIES_PREFIX = "Your project can only contain the dependencies listed in:"
    private static final String ERROR_ALLOWED_DEPENDENCIES_SUFFIX = "If you think one of them should be in the whitelist, please contact mobile-arquitectura@"

    private static final String FILE = "build/reports/${LibraryWhitelistedDependenciesLint.class.simpleName}/${Lint.LINT_FILENAME}"

    /**
     * Array with whitelisted dependencies
     */
    List<Dependency> WHITELIST_DEPENDENCIES

    /**
     * Checks the dependencies the project contains are in the whitelist
     */
    boolean lint(Project project, def variants) {
        if (!project.lintGradle.dependenciesLintEnabled) {
            return false
        }

        boolean hasFailed = false
        if (project.plugins.hasPlugin(BasePlugin.ANDROID_LIBRARY_PLUGIN)) {
            setUpWhitelist(project.lintGradle.dependencyWhitelistUrl as String)

            String DEFAULT_GRADLE_VERSION_VALUE = "unspecified" // Generated by Gradle/Maven by default for a project

            // This is a new run, so remove the file if it exists, we will override it
            if (project.file(FILE).exists()) {
                project.file(FILE).delete()
            }

            /**
             * Closure to report a forbidden dependency as error
             */
            def report = { message ->
                File file = project.file(FILE)
                // This will happen only the first time (since the first time it hasnt 'already failed'
                if (!hasFailed) {
                    // Create the file
                    if (!file.exists()) {
                        file.getParentFile().mkdirs()
                    }
                    // Flag it as failed and write to the stdout and file output.
                    hasFailed = true
                    println ERROR_TITLE
                    file << ERROR_TITLE
                }

                // Write file and stdout with message
                file.append("${System.getProperty("line.separator")}${message}")
                println message
            }

            // Core logic
            def analizeDependency = { dependency ->
                String dependencyFullName = "${dependency.group}:${dependency.name}:${dependency.version}"
                boolean isLocalModule =
                        project.rootProject.subprojects
                                .find { dependencyFullName.contains("${project.group}:${it.name}") } != null

                /**
                 * - Dependency cant be found in whitelist
                 * - Isnt "unspecified" the name of the dependency
                 * - Dependency isnt from the same group (you CAN compile dependencies from your own modules)
                 * Only if all of the above meet it will error.
                 */
                if (!dependencyFullName.contains(DEFAULT_GRADLE_VERSION_VALUE)
                        && !isLocalModule) {
                    Status result = dependencyIsInWhitelist(dependencyFullName)
                    if (result.reportable()) {
                        report result.message(dependencyFullName)
                    }
                }
            }

            // Check dependencies of each variant available first
            variants.each { variant ->
                String variantName = variant.name
                project.configurations."${variantName}Api".dependencies.each {
                    analizeDependency(it)
                }
                project.configurations."${variantName}Implementation".dependencies.each {
                    analizeDependency(it)
                }
            }

            // Check the default compiling deps
            project.configurations.api.dependencies.each {
                analizeDependency(it)
            }
            project.configurations.implementation.dependencies.each {
                analizeDependency(it)
            }

            if (hasFailed) {
                report("${ERROR_ALLOWED_DEPENDENCIES_PREFIX} ${project.lintGradle.dependencyWhitelistUrl}\n${ERROR_ALLOWED_DEPENDENCIES_SUFFIX}")
            }
        }

        return hasFailed
    }

    /**
     * Returns the task name
     */
    String name() {
        return "lintDependencies"
    }

    /**
     * Method to check if a dependency exists in the whitelist.
     * @returns Status notifying the result
     */
    Status dependencyIsInWhitelist(String dependency) {
        for (Dependency whitelistDep : WHITELIST_DEPENDENCIES) {
            if (dependency =~ /${whitelistDep.group}:${whitelistDep.name}:${whitelistDep.version}/) {
                if (System.currentTimeMillis() < whitelistDep.expires) {
                    return Status.AVAILABLE
                } else {
                    return Status.EXPIRED
                }
            }
        }
        
        return Status.INVALID
    }

    /**
     * Sets up the whitelist, this will get a json from the whitelistUrl defined
     * and parse the formatted JSON into a list of dependencies
     * @param whitelistUrl well formed url with JSON content
     */
    void setUpWhitelist(String whitelistUrl) {
        WHITELIST_DEPENDENCIES = new ArrayList<String>()

        new URL(whitelistUrl).openConnection().with { conn ->
            def jsonSlurper = new JsonSlurper().parseText(conn.inputStream.text)
            jsonSlurper.whitelist.each { dependency ->
                WHITELIST_DEPENDENCIES.add(new Dependency().with {
                    group = dependency.group ?: '.*'
                    name = dependency.name ?: '.*'
                    version = dependency.version ?: '.*'

                    expires = dependency.expires ?
                            new Date().parse("yyyy-M-d", dependency.expires).time :
                            Long.MAX_VALUE

                    return it
                })
            }
        }
    }

    /**
     * Status for a dependency respecting the whitelist
     */
    static enum Status {
        /**
         * Implies that the dependency is in the whitelist
         * The repository can use this dependency
         */
        AVAILABLE(false),
        /**
         * Implies that the dependency is not in the whitelist or the version
         * is not the correct one.
         * The repository shouldnt have this dependency, or this particular version.
         */
        INVALID(true),
        /**
         * Implies that the dependency is in the whitelist, but it has already expired
         * The repository should either remove this dependency, or update its expiry time
         * in the whitelist.
         */
        EXPIRED(true)

        private boolean shouldReport

        Status(boolean shouldReport) {
            this.shouldReport = shouldReport
        }

        /**
         * If the status can be reported or not
         * @return boolean notifying if the status can be reported
         */
        boolean reportable() {
            return shouldReport
        }

        /**
         * Returns a formatted message for the dependency
         * @param dependency to format in the message
         * @return formatted message to print
         * @throws IllegalAccessException if trying to report a non reportable status
         */
        String message(String dependency) {
            if (!reportable()) {
                throw new IllegalAccessException('Cant report this type of dependency')
            }
            return "- ${dependency} (${name().toLowerCase().capitalize()})"
        }
    }

    /**
     * Whitelist Dependency DTO
     */
    static class Dependency {

        /**
         * groupId per pom definition
         */
        String group

        /**
         * name / artifactId per pom definition
         */
        String name

        /**
         * Versionper pom definition
         */
        String version

        /**
         * Date time when the dependency becomes invalid. Until then, its considered
         * as a valid dependency
         *
         * Time is measured in milliseconds
         */
        long expires

    }

}
