package com.mercadolibre.android.gradle.base.lint.dependencies

import com.mercadolibre.android.gradle.base.BasePlugin
import com.mercadolibre.android.gradle.base.lint.Lint
import groovy.json.JsonSlurper
import org.gradle.api.Project

/**
 * Class that lints the dependencies in the project checking that it only
 * compiles the whitelisted ones
 *
 * Author: Santi Aguilera
 */
class LibraryWhitelistedDependenciesLint implements Lint {

    private static final String ERROR_TITLE = "Error: Found dependencies not allowed:"
    private static final String ERROR_ALLOWED_DEPENDENCIES = "Please check your dependencies.\nYou can see the allowed dependencies at:"

    private static final String FILE = "build/reports/${LibraryWhitelistedDependenciesLint.class.simpleName}/${Lint.LINT_FILENAME}"

    /**
     * Array with whitelisted dependencies
     */
    List<Dependency> WHITELIST_DEPENDENCIES

    /**
     * Checks the dependencies the project contains are in the whitelist
     * 
     * This throws GradleException if errors are found.
     */
    boolean lint(Project project, def variants) {
        if (!project.rootProject.lintGradle.dependenciesLintEnabled) {
            return false
        }

        boolean hasFailed = false
        if (project.plugins.hasPlugin(BasePlugin.ANDROID_LIBRARY_PLUGIN)) {
            setUpWhitelist(project.rootProject.lintGradle.dependencyWhitelistUrl as String)

            String DEFAULT_GRADLE_VERSION_VALUE = "unspecified" // Generated by Gradle/Maven by default for a project

            // This is a new run, so remove the file if it exists, we will override it
            if (project.file(FILE).exists()) {
                project.file(FILE).delete()
            }

            /**
             * Closure to report a forbidden dependency as error
             */
            def report = { message ->
                File file = project.file(FILE)
                // This will happen only the first time (since the first time it hasnt 'already failed'
                if (!hasFailed) {
                    // Create the file
                    if (!file.exists()) {
                        file.getParentFile().mkdirs()
                    }
                    // Flag it as failed and write to the stdout and file output.
                    hasFailed = true
                    println ERROR_TITLE
                    file << ERROR_TITLE
                }

                // Write file and stdout with message
                file.append("${System.getProperty("line.separator")}${message}")
                println message
            }

            // Core logic
            def analizeDependency = { dependency ->
                String dependencyFullName = "${dependency.group}:${dependency.name}:${dependency.version}"
                String message = "- ${dependencyFullName}"
                boolean isLocalModule =
                        project.rootProject.subprojects
                                .find { dependencyFullName.contains("${project.group}:${it.name}") } != null

                /**
                 * - Dependency cant be found in whitelist
                 * - Isnt "unspecified" the name of the dependency
                 * - Dependency isnt from the same group (you CAN compile dependencies from your own modules)
                 * Only if all of the above meet it will error.
                 */
                if (!dependencyFullName.contains(DEFAULT_GRADLE_VERSION_VALUE)
                        && !isLocalModule) {
                    Status result = dependencyIsInWhitelist(dependencyFullName)
                    if (result == Status.INVALID || result == Status.EXPIRED) {
                        report("${message}${result == Status.EXPIRED ? " (expired)" : ""}")
                    }
                }
            }

            // Let the dependencies be resolved, so we lint against non-dynamic ones
            project.afterEvaluate {
                // Check dependencies of each variant available first
                variants.each { variant ->
                    String variantName = variant.name

                    if (project.configurations.hasProperty("${variantName}Compile")) {
                        project.configurations."${variantName}Compile".dependencies.each {
                            analizeDependency(it)
                        }
                    }
                }

                // Check the default compiling deps
                project.configurations.compile.dependencies.each { analizeDependency(it) }
            }

            if (hasFailed) {
                report("${ERROR_ALLOWED_DEPENDENCIES} ${project.rootProject.lintGradle.dependencyWhitelistUrl}")
            }
        }

        return hasFailed
    }

    /**
     * Returns the task name
     */
    String name() {
        return "lintDependencies"
    }

    /**
     * Method to check if a dependency exists in the whitelist.
     * In case it does exist, but the dependency is expired in the whitelist, it will still return
     * false
     *
     * Supports regular expressions for the array values.
     */
    Status dependencyIsInWhitelist(String dependency) {
        for (Dependency whitelistDep : WHITELIST_DEPENDENCIES) {
            if (dependency =~ /${whitelistDep.group}:${whitelistDep.name}:${whitelistDep.version}/) {
                if (System.currentTimeMillis() < whitelistDep.timeoutMs) {
                    return Status.AVAILABLE
                } else {
                    return Status.EXPIRED
                }
            }
        }
        
        return Status.INVALID
    }

    void setUpWhitelist(String whitelistUrl) {
        WHITELIST_DEPENDENCIES = new ArrayList<String>()

        new URL(whitelistUrl).openConnection().with { conn ->
            def jsonSlurper = new JsonSlurper().parseText(conn.inputStream.text)
            jsonSlurper.whitelist.each { dependency ->
                WHITELIST_DEPENDENCIES.add(new Dependency().with {
                    group = dependency.group ?: '.*'
                    name = dependency.name ?: '.*'
                    version = dependency.version ?: '.*'

                    timeoutMs = dependency.expires ?
                            new Date().parse("yyyy-M-d", dependency.expires).time :
                            Long.MAX_VALUE

                    return it
                })
            }
        }
    }

    static enum Status {
        AVAILABLE,
        INVALID,
        EXPIRED
    }

    static class Dependency {
        String group
        String name
        String version
        long timeoutMs
    }

}
