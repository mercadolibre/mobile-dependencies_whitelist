package com.mercadolibre.android.gradle.base.lint.dependencies

import com.mercadolibre.android.gradle.base.lint.Lint
import groovy.json.JsonSlurper
import org.gradle.api.Project

/**
 * Class that lints the dependencies in the project checking that it only
 * compiles the whitelisted ones
 *
 * Author: Santi Aguilera
 */
class DependenciesLint implements Lint {

    private static final String ERROR_TITLE = "Error: Found dependencies not allowed:"
    private static final String ERROR_ALLOWED_DEPENDENCIES = "Please check your dependencies.\nYou can see the allowed dependencies at:"

    private static final String FILE = "build/reports/lint_dependencies/lint.ld"

    /**
     * Array with whitelisted dependencies
     */
    List<String> WHITELIST_DEPENDENCIES

    /**
     * Checks the dependencies the project contains are in the whitelist
     * 
     * This throws GradleException if errors are found.
     */
    boolean lint(Project project, def variants) {
        setUpWhitelist(project.rootProject.lintGradle.dependencyWhitelistUrl as String)

        boolean hasFailed = false
        String DEFAULT_GRADLE_VALUE = "unspecified" // Generated by Gradle/Maven by default for a project

        // This is a new run, so remove the file if it exists, we will override id
        if (project.file(FILE).exists()) {
            project.file(FILE).delete()
        }
        
        /**
         * Closure to report a forbidden dependency as error
         */
        def report = { message ->
            File file = project.file(FILE)
            if (!hasFailed) {
                // This is the first time it will find an error..
                if (!file.exists()) {
                    file.getParentFile().mkdirs()
                }
                // If it fails, we flag it as such and we write to the stdout and file output.
                hasFailed = true
                println ERROR_TITLE
                file << ERROR_TITLE
            }
            file.append("${System.getProperty("line.separator")}${message}")
            println message
        }

        // Core logic
        def analizeDependency = { dependency ->
            // The ASCII chars make the stdout look red.
            String dependencyFullName = "${dependency.group}:${dependency.name}:${dependency.version}"
            String message = "- ${dependencyFullName}"
            boolean isLocalModule =
                project.rootProject.subprojects
                        .find { dependencyFullName.contains("${project.group}:${it.name}") } != null

            /**
             * - Dependency cant be found in whitelist
             * - Isnt "unspecified" the name of the dependency
             * - Dependency isnt from the same group (you CAN compile dependencies from your own modules)
             * Only if all of the above meet it will error.
             */
            if (!dependencyFullName.contains(DEFAULT_GRADLE_VALUE)
                    && !isLocalModule
                    && !dependencyIsInWhitelist(dependencyFullName)) {
                report(message)
            }
        }

        // Check dependencies of each variant available first
        variants.each { variant ->
            String variantName = variant.name

            if (project.configurations.hasProperty("${variantName}Compile")) {
                project.configurations."${variantName}Compile".dependencies.each { analizeDependency(it) }
            }
        }

        // Check the default compiling deps
        project.configurations.compile.dependencies.each { analizeDependency(it) }

        if (hasFailed) {
            report("${ERROR_ALLOWED_DEPENDENCIES} ${project.rootProject.lintGradle.dependencyWhitelistUrl}")
        }

        return hasFailed
    }

    /**
     * Returns the task name
     */
    String name() {
        return "lintDependencies"
    }

    /**
    * Method to check if a part of a string is contained in
    * at least one of the strings of the array
    * eg array = [ "abc", "def", "ghi" ]
    * array.containsPartOf("ab") -> true
    * array.containsPartOf("hi") -> true
    * 
    * Supports regular expressions for the array values.
    */
    def dependencyIsInWhitelist(String dependency) {
        for (String whitelistDep : WHITELIST_DEPENDENCIES) {
            if (dependency =~ /${whitelistDep}/) {
                return true
            }
        }
        
        return false
    }

    def setUpWhitelist(String whitelistUrl) {
        WHITELIST_DEPENDENCIES = new ArrayList<String>()

        new URL(whitelistUrl).openConnection().with { conn ->
            def jsonSlurper = new JsonSlurper().parseText(conn.inputStream.text)
            jsonSlurper.whitelist.each { dependency ->
                WHITELIST_DEPENDENCIES.add(dependency)
            }
        }
    }

}
